# **当异步任务学会温柔告别**

有些线程像人，有些退出像分手。
有的轻声道别，有的摔门走人。
而 Java 的异步世界，也藏着同样的情绪。

今天就带你看看
异步线程的退场方式。
分两类：

1. 指定线程池与未指定线程池
2. 软关闭与强制停止

一共四种告别场景，每一种都有不同的力度与浪漫。

------

## 一、未指定线程池的异步线程：ForkJoinPool 的独自漂浮

当你这样写：

```java
CompletableFuture.runAsync(() -> {
        System.out.println("异步执行中...");
});
```

你没有指定线程池，JDK8 会自动把任务扔进 `ForkJoinPool.commonPool()`。
这个公共线程池属于整个 JVM 共享，像公共食堂一样，谁都能吃，谁都能往里扔活。

### 1.1 软关闭：JVM 结束时自然退出

没有关闭机制。
你只能靠 JVM 结束时，它们随着世界一同熄灯。
就像“自然分手”，没有争吵，只是不再相见。

这类线程池没法单独 shutdown、没办法优雅关闭，只能：

- 减少投喂任务
- 等程序结束

**优点**：自然、无需管理
**缺点**：无法单独控制线程池生命周期

------

## 二、指定线程池时：你的线程池你做主

当你这样写：

```java
ExecutorService executor = Executors.newFixedThreadPool(3);
CompletableFuture.runAsync(() -> {
        System.out.println("任务执行中...");
}, executor);
```

你就能掌控它的命运。
此处线程池就像你领养的小猫，你能决定它何时睡、何时停、何时强制终止。

线程池的关闭方式分两类：

### 2.1 软关闭（优雅退出）shutdown()

```java
executor.shutdown();
```

软关闭特点：

- 不再接收新任务
- 正在执行的任务继续执行
- 等所有任务执行完后才真正关闭

适合作为“甜甜不闹的分手”：
我们把事情做完，然后各奔东西。

### 示例

```java
ExecutorService executor = Executors.newFixedThreadPool(3);

executor.submit(() -> {
        try { Thread.sleep(2000); } catch (Exception ignored) {}
        System.out.println("慢慢做完再离开");
});

        executor.shutdown(); // 温柔关闭
```

------

### 2.2 强制停止（立即终止）shutdownNow()

```java
List<Runnable> notExecuted = executor.shutdownNow();
```

强制停止特点：

- 立即尝试停止所有任务
- 向正在运行的线程发送 interrupt
- 返回未开始执行的任务列表
- 不保证一定能停住，但会尽力让线程“被中断”

这是属于“掀桌式分手”：
不想等了、说停就停。

### 示例

```java
ExecutorService executor = Executors.newFixedThreadPool(3);

executor.submit(() -> {
        while (!Thread.currentThread().isInterrupted()) {
        System.out.println("我还在努力...");
    }
            System.out.println("收到中断信号，准备撤退");
});

        executor.shutdownNow(); // 强制停止
```

------

## 三、CompletableFuture 本身的关闭方式

很多人以为 CompletableFuture 也能关闭，其实不行。
它没有 shutdown 方法，因为它本身不管理线程。

想停止任务，只能通过：

### 3.1 `cancel(true)`

```java
future.cancel(true);
```

会向执行它的线程发送 interrupt 信号。
同样也分两种：

- cancel(true)：请求中断
- cancel(false)：只取消，不中断

但前提是任务内部要自己响应中断：

```java
while (!Thread.currentThread().isInterrupted()) {
        // 工作中...
        }
```

否则线程还是不会停。

------

## 四、完整示例：指定线程池 + 软关闭与强制停止

### 4.1 温柔版：shutdown()

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
 try {
  Thread.sleep(3000);
  System.out.println("温柔退场完成");
 } catch (InterruptedException e) {
  System.out.println("被轻轻打断了");
 }
}, executor);

executor.shutdown();
```

------

### 4.2 暴躁版：shutdownNow()

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
 try {
  while (true) {
   if (Thread.currentThread().isInterrupted()) {
    System.out.println("收到强制退场通知");
    break;
   }
  }
 } catch (Exception e) {
  System.out.println("异常退场");
 }
}, executor);

executor.shutdownNow();
```

------

## 五、总结：四种告别方式，一颗程序员的心

| 是否指定线程池   | 关闭方式            | 是否可控 | 行为方式     |
| ---------------- | ------------------- | -------- | ------------ |
| 否（commonPool） | JVM 结束退出        | 否       | 自然消亡     |
| 是               | shutdown            | 是       | 温柔告别     |
| 是               | shutdownNow         | 是       | 强制中断     |
| 是               | future.cancel(true) | 部分     | 中断执行线程 |

每一种关闭方式，都像关系里的一种离场方式。
温柔也好，决绝也罢，关键是你要知道你想要什么。

------

