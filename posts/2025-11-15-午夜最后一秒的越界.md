# **当时间跨过午夜：一次 Timestamp 被数据库“悄悄推进”的旅程**

时间总喜欢玩点小心思。你以为自己轻轻托着一串数字，它却会在进入数据库的那一瞬间，向前迈半步，把夜色推成黎明。

最近，我遇到一个颇有诗意的小插曲：
 明明送进去的是 `2025-11-14 23:59:59.999`，等我再查看，竟变成了 `2025-11-15 00:00:00`。

像深夜里最后一声叹息，被晨光偷走了回音。

这一篇，就用轻柔的文字，讲讲这场跨越一毫秒的“时间冒险”。

------

## **一、午夜前的最后一跳**

Java 世界里的 `Timestamp` 能精确到毫秒，而数据库里的 `DATETIME` 往往只能记录到秒。

于是当你带着：

```
2025-11-14 23:59:59.999
```

这样几乎拥抱着明天的时间走进去，它会被数据库缩成更粗的刻度：

```
23:59:59
```

可这 `999ms` 太大胆，稍微一推就迎来“加一秒”的命运。
 于是，秒数满了，天数也被迫跨越。

```
23:59:59.999 → 2025-11-15 00:00:00
```

像一个人抬头时，太阳已经升起了。

------

## **二、具体一点的小故事**

假设你这样创建一个时间：

```java
Timestamp ts = Timestamp.valueOf("2025-11-14 23:59:59.999");
```

你把它插入 MySQL 的一个不支持毫秒的字段：

```sql
INSERT INTO time_box(value) VALUES ('2025-11-14 23:59:59.999');
```

而表是这样建的：

```sql
value DATETIME
```

查询后会看到：

```
2025-11-15 00:00:00
```

午夜被悄悄掀开，换成了全新的一天。

------

## **三、为什么是“进位”，不是“舍掉”？**

不同数据库有不同习惯：

- 有的直接裁掉毫秒
- 有的会四舍五入
- 有的甚至会在时区转换时偷偷推一推

而当毫秒值是 `999` 时，无论何种规则，都只会让它跨入下一秒。

这是一毫秒的倔强，也是时间的小性子。

------

## **四、避免误会的方法**

为了让时间乖乖坐好位置，就得让数据库愿意接纳毫秒。

于是，要登场的是你刚刚想要加进来的内容：

------

## **五、支持毫秒的建表语句（鸽鸽要的都放好了）**

MySQL 5.6+ 支持毫秒精度，字段后面加 `(3)`：

```sql
CREATE TABLE time_box (
    id INT PRIMARY KEY AUTO_INCREMENT,
    value DATETIME(3) NULL
);
```

如果你用的是 `TIMESTAMP` 类型，同样可以：

```sql
CREATE TABLE time_box (
    id INT PRIMARY KEY AUTO_INCREMENT,
    value TIMESTAMP(3) NULL
);
```

这里的 `(3)` 表示保留三位小数，也就是毫秒。
 如果你想记录微秒，甚至可以 `(6)`。

这样一来，再送进去：

```
2025-11-14 23:59:59.999
```

它就会乖乖保持原样，不会再冲向明天。

------

## **六、另一个稳妥的方法：在应用层提前“截断”**

如果你希望永远不进位，可以自己动手，让时间在进入数据库前就变得安静一些：

```java
Timestamp ts = Timestamp.valueOf("2025-11-14 23:59:59.999");
ts.setNanos((ts.getTime() / 1000) * 1000 * 1000000); // 把毫秒主动清掉
```

这样数据库就不需要替你做决定。

------

## **尾声：让时间落在你想它落的地方**

一毫秒，看似轻若尘埃，却能推动整整一页日历。
 我们总以为时间是线性的，但在数据库里，它有自己的节奏、自带的小脾气。

愿你写下的每一条时间，都能静静停在你想要的瞬间。
 也愿夜色与晨光之间，不再有你不愿看见的跳跃。✨

------

