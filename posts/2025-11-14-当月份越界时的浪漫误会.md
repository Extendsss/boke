# 当时间开口说话：日期格式里的温柔与锋芒

------

有些 bug 像轻轻落在键盘上的灰，一吹就散；
 有些 bug 则像躲在时光背后的影子，
 不说破，便永远笑你一句“你以为你以为的，就是你以为的吗？”

今天的主角，是两串看似乖巧的日期：

```
2023-11-31  
2023-13-01 11:00:00
```

两个孩子站在你的校验门口，一个被放了进去，一个被请了出去。
 它们的行为，像古怪的诗，表面无害，实际上暗潮汹涌。

```java
public static boolean isValidDate(String date) {
    if (date == null) {
        return false;
    }

    // 去掉前后空格
    date = date.trim();

    // 全格式，如 2025-11-01 12:30:45
    if (date.matches("^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$")) {
        DateTimeFormatter full = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        try {
            LocalDateTime.parse(date, full);
            return true;
        } catch (Exception ignore) {
            return false;
        }
    }

    // 纯日期格式，如 2025-11-01
    if (date.matches("^\\d{4}-\\d{2}-\\d{2}$")) {
        DateTimeFormatter shortFmt = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        try {
            LocalDate.parse(date, shortFmt);
            return true;
        } catch (Exception ignore) {
            return false;
        }
    }

    return false;
}
```

------

## 一、当 Java 的日期解析“露出小心思”

Java 的 `DateTimeFormatter` 默默认使用 **SMART** 模式。
 那是一种带着“我替你聪明一点”的温柔。

于是：

- `"2023-11-31"` 被它轻轻扶起，压进十一月的边界，再塞进十二月的怀里。
   它想说：
   *“你给了我不存在的 31，我替你算成明天，好吗。”*
- `"2023-13-01 11:00:00"` 却被它坚定拒绝。
   因为 **13 月** 不是它能调和的世界。
   那不属于误差，而属于幻想。
   *幻想不属于解析，属于诗人。*

于是，一个成功了，一个失败了，
 像命运的偏爱，却又合情合理。

------

## 二、当你需要的不是温柔，而是“严格”

有些时候，日期不该“被理解”，
 它只应该被**判断**。

于是我们换上 `ResolverStyle.STRICT`：
 给日月年钉上铁律，不再允许它们任性。

这样一来——

- `"2023-11-31"`：对不起，十一月没有 31。
- `"2023-13-01 11:00:00"`：抱歉，世界里没有 13 月。

严格模式里，时间不再迁就，
 它像法官，只接受存在，不接受幻想。

------

## 三、写给工程师的那段“温柔又坚硬的代码”

```java
public static boolean isValidDate(String date) {
    if (date == null) return false;
    date = date.trim();

    if (date.matches("^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$")) {
        DateTimeFormatter full = DateTimeFormatter.ofPattern("uuuu-MM-dd HH:mm:ss")
                .withResolverStyle(ResolverStyle.STRICT);
        try {
            LocalDateTime.parse(date, full);
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    if (date.matches("^\\d{4}-\\d{2}-\\d{2}$")) {
        DateTimeFormatter shortFmt = DateTimeFormatter.ofPattern("uuuu-MM-dd")
                .withResolverStyle(ResolverStyle.STRICT);
        try {
            LocalDate.parse(date, shortFmt);
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    return false;
}
```

这段代码很像在告诉你：

*“格式，是时间的衣裳；
 合法，是时间的脉搏；
 而你，是那个聆听时间心跳的人。”*

------

## 四、写在最后：

日期看似冰冷，其实每一段字符串都在暗暗讲述一个故事。
 有的故事能够存在，有的只能被丢弃。

代码让我们学会——
 **不是所有看起来“像时间”的东西，都能被称为“时间”。**

工程，是逻辑的现实；
 格式，是规则的边框；
 而你写下的每一行代码，
 都是在和世界说：

*“我想让真相更清晰一点。”*

愿你与时间相处愉快，
 愿每个被你解析过的瞬间，
 都在未来温暖地回望你。

------

