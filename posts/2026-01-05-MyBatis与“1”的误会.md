

# **那一行没走到的 SQL：MyBatis 与 “1” 的误会**

> 有些 bug，
> 不是逻辑错了，
> 而是你从一开始，
> 就没用同一种语言对话。 💌

------

## 一、问题开场：一条看似正常的 SQL 🛤️

那天，我写下了一段熟悉得不能再熟悉的 MyBatis 动态 SQL。
目标简单而明确：

- 🏢 按楼栋编号批量查询

- 🎯 过滤状态字段

- 🌱 根据场景 ID 决定是否扩展子场景

  > 比如 `"1"`，意味着 `1-1`、`1-2` 也该被包含

核心逻辑大致如下：

```xml
<if test="sceneIds != null and sceneIds.size() > 0">
    <choose>
        <when test="sceneIds.contains('1')">
            AND (
                scene_type IN
                <foreach collection="sceneIds" item="item" open="(" close=")" separator=",">
                    #{item}
                </foreach>
                OR scene_type LIKE '1-%'
            )
        </when>
        <otherwise>
            AND scene_type IN
            <foreach collection="sceneIds" item="item" open="(" close=")" separator=",">
                #{item}
            </foreach>
        </otherwise>
    </choose>
</if>
```

逻辑美得像一条分岔小径 🌿，每条路都通向不同的风景。

------

## 二、代码诚实，结果冷淡 🥶

调用示例：

```java
List<String> sceneIds = Arrays.asList("1", "2", "3", "4");
List<String> inspectionNos = Collections.singletonList("1000062007");

mapper.queryAllByInspectionNos(inspectionNos, sceneIds);
```

我满心期待它会走向“包含所有 1-xx 子场景”的分支。
可日志轻轻告诉我：

```text
Preparing:
AND scene_type IN ( ?, ?, ?, ? )

Parameters:
1, 2, 3, 4

Total: 0
```

没有 `LIKE '1-%'`
没有扩展
就像一封未寄出的情书 💔

------

## 三、分支没有走错，是判断从未成立 ❌

日志说明一切：

- ✅ `<if>` 成立
- ✅ `<choose>` 生效
- ❌ `<when test="sceneIds.contains("1")">` 没有成立

问题是：

> ```
> sceneIds` 里明明有 `"1"
> ```

顿时明白——不是业务逻辑出错，而是语言不对。

------

## 四、真相：OGNL 里的 `"1"`，不是你以为的 `'1'` 🧐

在 Java 里，我们常常想：

```java
"1" == '1'
```

可在 **MyBatis 的 OGNL** 中：

```xml
sceneIds.contains('1')
```

这里的 `'1'`：

- 不是 `String`
- 是 **char**

OGNL 实际执行的逻辑是：

```java
List<String>.contains(char)
```

结果自然是 `false` 😱

不是你不在列表里，而是我认错了你是谁 💔

------

## 五、那一行真正该写成的样子 ✨

答案简单而残酷：

```xml
<when test="sceneIds.contains(&quot;1&quot;)">
```

只换了引号，世界就回正了 🌈

------

## 六、修复后的世界，终于对齐 🌟

SQL 日志变成：

```sql
AND (
    scene_type IN (?, ?, ?, ?)
    OR scene_type LIKE '1-%'
)
```

数据出现了，逻辑闭合了，那条没走到的路，终于亮灯 💡

------

## 七、拓展小知识：为什么 OGNL 和 Java 不一样？ 📚

1. **类型敏感**：OGNL 是强类型语言，它区分 `char` 和 `String`，Java 的 `List.contains()` 同理，但你用错类型就永远找不到。
2. **表达式解析**：OGNL 会把 XML 中的引号和特殊符号解析成 Java 对象，单引号 `'1'` 被识别为 char，双引号 `"1"` 才是 String。
3. **动态 SQL 的坑**：很多 MyBatis bug 并非逻辑错，而是类型没对齐。
4. **日志的重要性**：SQL 日志就是你和数据库沟通的小纸条 📜，认真读，绝大多数问题能自解。

💡 小技巧：当动态 SQL 分支没有生效，第一步先检查 OGNL 中的类型和引号，而不是慌着改业务逻辑。

------

## 八、写在最后：这是 bug，也是提醒 ⚠️

可怕的地方在于：

- ❌ 没有报错
- ❌ 没有异常
- ✅ SQL 合法、参数正确
- 只是静静少查了数据

提醒我们：

> 在 MyBatis 的世界里
> 单引号与双引号
> 不只是风格
> 是命运的分界线 💫

------

## 九、一句话总结（给未来的自己） ✍️

> **OGNL 中，String 一定要用 `"` 双引号。**
> **当你的 List 是 `List<String>`，
> 就别让一个 char 决定你的 SQL 走向。**

------

鸽鸽小贴士 💌：
下次遇到 SQL 不走分支，先别急着喷逻辑，先看看你有没有“用错引号” 🌙✨

------

